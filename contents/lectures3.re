= 補遺
== 補足 その１
 * 自作関数の例
//list[][][file=source/lecture_extra/add.c,1]{
//}
 * 符号付き, 符号無し, 浮動小数点数の誤差
//list[][][file=source/lecture_extra/binary.c,1]{
//}
 * ファイル一覧(Mac版)
//list[][][file=source/lecture_extra/file_entry.c,1]{
//}
#@#  * 文字化け対策の例
#@# //list[][][file=source/lecture_extra/moji_shiftjis.c,1]{
#@# //}
 * メモリの動的確保
//list[][][file=source/lecture_extra/realloc_sample.c,1]{
//}
 * 前置と後置
//list[][][file=source/lecture_extra/prefix_postfix.c,1]{
//}


== 補足 その２

=== フローチャート


@<href>{http://qiita.com/dokubeko/items/4d7dd1d6d959df30fa9c,"プログラムの処理の流れ"のフローチャートの書き方}



http://qiita.com/dokubeko/ を参照


== ASCII コード表


@<href>{http://e-words.jp/p/r-ascii.html,ASCII文字コード}



(http://e-words.jp/p/r-ascii.html) を参照


== 再帰

//quote{
  再帰（さいき）とは、あるものについて記述する際に、記述しているものそれ自身への参照が、その記述中にあらわれることをいう。定義において、再帰があらわれているものを再帰的定義という。(@<href>{https://ja.wikipedia.org/wiki/再帰,再帰}
//}


@<href>{https://ja.wikipedia.org/wiki/状態遷移図,状態遷移図}

//quote{
  状態遷移図（じょうたいせんいず、State Transition Diagram）とは、有限オートマトンをグラフィカルに表現するために使われる図のこと。(Wikipediaより)
//}


@<href>{http://www9.plala.or.jp/sgwr-t/c/sec12.html,記憶クラス}

変数の記憶クラス(auto, static, register, extern)
関数の記憶クラス(extern, static)


@<href>{https://ja.wikipedia.org/wiki/列挙型,列挙型}

//quote{
  列挙型（enumerated type）とは、コンピュータプログラミングにおいて、プログラマが選んだ各々の識別子をそのまま有限集合として持つ抽象データ型である。列挙型は一般に番号順を持たないカテゴリ変数(カードの組のように)として使われる。実行時には、列挙型は整数で実装されることが多い（各々の識別子は異なる整数値を持つ）。

  また列挙型は、整数を使用する場合と比較して、明示的にマジックナンバーを使用するよりもプログラムソースの可読性を改善するのに役立つ。言語によっては、列挙型の整数表現はプログラマに見えないようになっていることもあり、これによりプログラマが列挙値に対して算術演算を行うような乱用を防いでいる。

  言語によっては、真偽値の論理型は、あらかじめ宣言された二値の列挙型とされている。(Wikipediaより)
//}

@<href>{https://ja.wikipedia.org/wiki/共用体,共用体}

//quote{
  共用体（きょうようたい、union）は、プログラミング言語におけるデータ型の一つで、同じメモリ領域を複数の型が共有する構造である。

  例として、ある入力が数字の場合は数値として、そうでない場合は文字列のまま保持したいという場合を考える。この場合、数値用と文字列用の領域をそれぞれ用意するのが一つの解法だが、入力は数値か文字列のどちらか一方なので、片方しか使われず無駄が出る。そこで代わりに、格納用の領域を一つだけ用意して、これを数値である、文字列であると場合により解釈し分けることで領域の無駄が抑えられる。

  この「格納用の領域」こそが共用体である。(Wikipediaより)
//}

== 開発プロセス

@<href>{http://itpro.nikkeibp.co.jp/article/lecture/20061130/255501/,開発基本の基本を学ぶ}


== テスト

 1. テスト概論
  * テストの目的/品質との関わり
  * 一般的なテストの流れ(計画→設計→実施)

 1. テストの種類
  * スコープによるテストの分類(単体・結合・システムテスト)
  * 目的によるテストの分類(機能・非機能・システムテスト)

 1. テスト手法
  * ブラックボックス法
  * ホワイトボックス法

 1. 代替プログラム
  * スタブとドライバ
  * スタブを使ったテスト

(http://www.ogis-ri.co.jp/learning/c-02-00000298.htmlより)


@<href>{https://ja.wikipedia.org/wiki/オブジェクト指向,オブジェクト指向}


<div style="text-align:right">(Wikipediaより)</div><br>

//quote{
  オブジェクト指向とは、オブジェクト同士の相互作用として、システムの振る舞いをとらえる考え方である。英語の object-oriented (直訳は、「対象物志向の」「目的重視の」という意味の形容詞) の日本語訳である。
  オブジェクト指向の枠組みが持つ道具立ては、一般的で強力な記述能力を持つ。複雑なシステム記述、巨大なライブラリ（特に部品間で緊密で複雑な相互関係を持つもの）の記述においては、オブジェクト指向の考え方は必須である。
//}


=== パラダイムとしてのオブジェクト指向

//quote{
  オブジェクト指向分析が提唱される以前には、システム分析のレベルにおいては、データ構造を中心としたシステムの分析技法である構造化技法が存在した。

  また、プログラミングのレベル (プログラミングパラダイム) では、プログラムの実行の流れを決められた制御構造の組み合わせとして書き下す構造化プログラミングや、カプセル化を促すモジュールプログラミング、多態に対応するデータ指向プログラミングという技法が存在していた。オブジェクト指向手法はそれらを一般化しさらに推し進めたものであるという考え方がある。
//}

=== オブジェクト指向プログラミングの構成要件

オブジェクト指向プログラミングを構成する概念は次のようなものである。

 * カプセル化 (情報隠蔽)オブジェクトの振る舞いを隠蔽したり、オブジェクト内部のデータを隠蔽したり(データ隠蔽)、オブジェクトの実際の型を隠蔽したりすることをいう。これは古典的な可視性の定義である。また、オブジェクト指向プログラミングの概念拡大に伴い、必須と表現するのが不適切になりつつあるが、旧来の多くのオブジェクト指向言語が備えている性質には以下のものがある。

 * ポリモーフィズム (多態性)あるオブジェクトへの操作が呼び出し側ではなく、受け手のオブジェクトによって定まる特性。クラスベースのオブジェクト指向の場合には、派生クラスの複数分岐として多態性を実現する。 プロトタイプベースのオブジェクト指向の場合では関係がない概念とされる。

 * オブジェクト指向の方式
 ** クラスベース方式 — クラスを定義し、それを元にインスタンスを生成する方式である。継承ベースともいう。
 ** プロトタイプベース方式 — 既存のインスタンスを元に、新たなインスタンスを生成する方式である。インスタンスベースともいう。
 ** Mixin方式 — さまざまなオブジェクトの原型を組み合わせて一つのオブジェクトを構成する方式である。

=== オブジェクト指向の名称とメッセージング

//quote{
  Eclipseを開発したDave Thomasや、オブジェクト指向という言葉の生みの親であるAlan Kay博士は、オブジェクト指向という言葉は失敗だったと語っている。[1] これは、本来オブジェクト指向が重視すべきは「オブジェクト」ではなく「メッセージング」であるにもかかわらず「メッセージング」がおろそかにされているためである。特に言語の進歩において「オブジェクト」や「クラス」の側面ばかり強調される傾向にあり、Alan Kay博士は「Smalltalkが最高に好きという訳ではないが、他の言語に比べればマシである。」と述べている。
//}

@<href>{https://ja.wikipedia.org/wiki/オブジェクト指向プログラミング,オブジェクト指向プログラミング} (Wikipedia)も参考にして下さい。
